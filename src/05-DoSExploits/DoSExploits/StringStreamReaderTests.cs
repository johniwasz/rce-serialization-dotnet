using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using System.Threading.Tasks;
using Xunit.Abstractions;

namespace XmlExploits.Tests
{
    public class StringStreamReaderTests
    {
        private readonly ITestOutputHelper _output;

        public StringStreamReaderTests(ITestOutputHelper output)
        {
            _output = output;
        }

        [Fact]
        public void ReadExcessiveString()
        {
            try
            {
                using MemoryStream ms = GenerateLargeMemoryStream(2097152000);

                using StreamReader sr = new StreamReader(ms);

                string line;
                while ((line = sr.ReadLine()) != null)
                {
                    // Vulnerable code is processing the input line by line without validation.
                    // This allows an attacker to craft a malicious input, leading to a DoS.
                    _output.WriteLine("Processing: " + line);
                }

            }
            catch (IOException ioEx)
            {
                // Handle IO exceptions, which may occur if the stream is too large to read.
                _output.WriteLine("IOException: " + ioEx.Message);
            }
            catch (OutOfMemoryException memEx)
            {
                _output.WriteLine("OutOfMemoryException: " + memEx.Message);
            }
            catch (Exception ex)
            {
                _output.WriteLine("Error: " + ex.Message);
            }
        }


        public MemoryStream GenerateLargeMemoryStream(long memoryStreamBytes)
        {
            const int chunkSize = 1024 * 1024; // 1 MB chunks

            MemoryStream memoryStream = new MemoryStream();

            byte[] buffer = new byte[chunkSize];
            long totalBytesWritten = 0;

            while (totalBytesWritten < memoryStreamBytes)
            {
                try
                {
                    memoryStream.Write(buffer, 0, buffer.Length);
                    totalBytesWritten += buffer.Length;

                    // Optional: Log progress
                    if (totalBytesWritten % (chunkSize * 100) == 0)
                    {
                        _output.WriteLine($"Written {totalBytesWritten} bytes so far...");
                    }
                }
                catch (IOException ioEx)
                {
                    // Handle IO exceptions, which may occur if the stream is too large to read.
                    _output.WriteLine("IOException: " + ioEx.Message);
                }
            }
            _output.WriteLine($"MemoryStream created with {totalBytesWritten} bytes.");

            memoryStream.Seek(0, SeekOrigin.Begin); // Reset the position to the beginning of the stream for reading.   
            return memoryStream;
        }
    }
}
