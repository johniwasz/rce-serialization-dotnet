using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using System.Xml.Schema;
using Xunit.Abstractions;
using System.Diagnostics;
using Microsoft.VisualStudio.TestPlatform.Utilities;
using System.IO;

namespace XmlExploit.Tests
{
    public class XmlDenialOfServiceTests
    {
        private readonly ITestOutputHelper _output;

        public XmlDenialOfServiceTests(ITestOutputHelper output)
        {
            _output = output;
        }

        [Fact()]
        public void XmlDocumentLoadFailsWithDepth()
        {
            string xmlText = GenerateXmlDocumentText(100);

            _output.WriteLine($"File byte length: {xmlText.Length}");

            var quotas = new XmlDictionaryReaderQuotas { MaxDepth = 32 };

            using var reader = XmlDictionaryReader.CreateTextReader(Encoding.UTF8.GetBytes(xmlText), quotas);

            Stopwatch testTime = Stopwatch.StartNew();
            XDocument xDoc = XDocument.Load(reader);
            testTime.Stop();


            _output.WriteLine($"XML file loaded successfully. Time taken: {testTime.ElapsedMilliseconds} ms");

        }

        [Fact(Skip = "Test Runs for 16+ hours demonstrating an Xml DoS vulnerability")]
        public void LoadLargeXmlFile()
        {
            string tempFilePath = Path.GetTempFileName();

            _output.WriteLine($"Temporary file path: {tempFilePath}");

            try
            {
                Stopwatch testTime = Stopwatch.StartNew();
                // This is too big for a string
                // GenerateXmlFile(188200000, tempFilePath);
                GenerateXmlFile(18820000, tempFilePath);
                testTime.Stop();
                _output.WriteLine($"Large Xml file generated. Time taken: {testTime.ElapsedMilliseconds} ms");

                string fileText = File.ReadAllText(tempFilePath);

                _output.WriteLine($"String length: {fileText.Length}");

                XmlReaderSettings readerSettings = new XmlReaderSettings
                {
                    // Disable DTD processing to prevent XXE attacks
                    DtdProcessing = DtdProcessing.Prohibit,
                    IgnoreWhitespace = true, // Optional: ignore whitespace
                    IgnoreComments = true,   // Optional: ignore comments
                    CloseInput = true,        // Ensure the reader closes the input stream
                    ValidationFlags = System.Xml.Schema.XmlSchemaValidationFlags.None, // Disable validation    
                    
                };

                using (XmlReader xmlReader = XmlReader.Create(new StringReader(fileText), readerSettings))
                {
                    testTime.Restart();
                    XDocument xDoc = XDocument.Load(xmlReader);
                    testTime.Restart();
                    _output.WriteLine($"XML file loaded successfully. Time taken: {testTime.ElapsedMilliseconds} ms");
                }
            }
            catch (Exception ex)
            {
                _output.WriteLine($"Error deleting temp file: {ex.Message}");
            }
            finally
            {
                // Clean up the temporary file if it still exists
                if (File.Exists(tempFilePath))
                {
                    try
                    {
                        File.Delete(tempFilePath);
                        _output.WriteLine($"Deleted temp file: {tempFilePath}");
                    }
                    catch (Exception ex)
                    {
                        _output.WriteLine($"Error deleting temp file in finally block: {ex}");
                    }
                }
            }
        }

        private string GenerateXmlDocumentText(int nodeDepth)
        {
            if (nodeDepth < 1)
            {
                throw new ArgumentException("Depth must be at least 1.");
            }

            StringBuilder xmlStringBuilder = new StringBuilder();

            xmlStringBuilder.Append("<root>");


            // Generate child nodes recursively
            for (int i = 1; i <= nodeDepth; i++)
            {
                xmlStringBuilder.Append($"<c{i}>");
            }

            // Close child nodes in reverse order
            for (int i = nodeDepth; i >= 1; i--)
            {
                xmlStringBuilder.Append("</c>");
            }

            xmlStringBuilder.Append("</root>");

            return xmlStringBuilder.ToString();

        }

        private void GenerateXmlFile(int nodeDepth, string tempFilePath)
        {
            ArgumentNullException.ThrowIfNullOrWhiteSpace(tempFilePath, nameof(tempFilePath));

            if (nodeDepth < 1)
            {                
                throw new ArgumentException("Depth must be at least 1.");
            }

            using (FileStream fileStream = new FileStream(tempFilePath, FileMode.Create, FileAccess.Write))
            {

                byte[] rootBytes = Encoding.UTF8.GetBytes("<root>");

                fileStream.Write(rootBytes);


                // Generate child nodes recursively
                for (int i = 1; i <= nodeDepth; i++)
                {
                    byte[] childOpen = Encoding.UTF8.GetBytes($"<c{i}>");
                    fileStream.Write(childOpen);
                }

                // Close child nodes in reverse order
                for (int i = nodeDepth; i >= 1; i--)
                {
                    byte[] childClose = Encoding.UTF8.GetBytes($"</c>");
                    fileStream.Write(childClose);
                }

                byte[] rootCloseBytes = Encoding.UTF8.GetBytes("</root>");
                fileStream.Write(rootCloseBytes);
                fileStream.Flush();
            }
        }
    }
}
